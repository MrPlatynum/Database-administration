# Министерство науки и высшего образования Российской Федерации

**Федеральное государственное автономное образовательное учреждение  
высшего образования  
«СЕВЕРО-КАВКАЗСКИЙ ФЕДЕРАЛЬНЫЙ УНИВЕРСИТЕТ»**

*Институт перспективной инженерии  
Департамент цифровых, робототехнических систем и электроники  
Межинститутская базовая кафедра*

---

## Отчет по лабораторной работе №1  
### дисциплины "Администрирование баз данных"

**Выполнил:** Душин Александр Владимирович  
4 курс, группа ПИЖ-б-о-22-1  
09.03.04 "Программная инженерия"  
направленность (профиль) "Разработка и сопровождение программного обеспечения"  
очная форма обучения  

**Руководитель практики:** Щеголев Алексей Алексеевич  
старший преподаватель департамента цифровых, робототехнических систем и электроники института перспективной инженерии

---

## Тема работы
Архитектура СУБД и конфигурация

## Цель работы
Изучить базовые компоненты архитектуры PostgreSQL (процессы, память) и получить практические навыки управления конфигурационными параметрами сервера на разных уровнях (экземпляр, сеанс). Освоить работу с основными и дополнительными файлами конфигурации, а также с представлениями `pg_settings` и `pg_file_settings`.

---

## Ход выполнения работы

### Часть 1. Исследование параметров и файлов конфигурации

#### 1. Определение текущей конфигурации
Выполнено подключение к серверу с помощью `psql`. Определено расположение основного файла конфигурации (`postgresql.conf`) с помощью команды `SHOW config_file;`. (Рис.1)

![Установка образа с PostgreSQL](./images/lab1-1.png)  
*Рисунок 1 – Определение расположения конфигурационного файла*

#### 2. Анализ параметров
Изучено представление `pg_settings`. Найдены параметры, для изменения которых требуется перезагрузка сервера (`context = 'postmaster'`). Найдены параметры с контекстами `sighup` и `user`. (Рис.2-3)

```sql
SELECT name, context, short_desc 
FROM pg_settings 
WHERE context = 'postmaster';
```

![context = 'postmaster'](./images/lab1-2.png)  
*Рисунок 2 – Параметры с контекстом postmaster*

```sql
SELECT name, context, short_desc 
FROM pg_settings 
WHERE context = 'sighup' 
LIMIT 5;

SELECT name, context, short_desc 
FROM pg_settings 
WHERE context = 'user' 
LIMIT 5;
```

![context = 'sighup', user](./images/lab1-3.png)  
*Рисунок 3 – Параметры с контекстами sighup и user*

#### 3. Анализ файлов конфигурации
Изучено представление `pg_file_settings`. Определено, из каких файлов и с какими значениями были считаны текущие настройки параметров `shared_buffers` и `work_mem`. (Рис.4)

![Анализ файлов конфигурации](./images/lab1-4.png)  
*Рисунок 4 – Анализ источников параметров конфигурации*

---

### Часть 2. Управление параметрами на уровне экземпляра

#### 1. Изменение через ALTER SYSTEM
С использованием команды `ALTER SYSTEM` установлено новое значение для параметра `work_mem`. Проверено, что изменение записалось в файл `postgresql.auto.conf` (используя функцию `pg_read_file`). Применено изменение перечитыванием конфигурации (`SELECT pg_reload_conf();`). Проверено новое значение параметра и его источник в `pg_settings`. (Рис.5)

![Изменение через ALTER SYSTEM](./images/lab1-5.png)  
*Рисунок 5 – Изменение параметра через ALTER SYSTEM*

#### 2. Изменение через дополнительный файл
Создан файл в каталоге, указанном в директиве `include_dir` основного конфигурационного файла. Установлено значение для параметра `log_min_duration_statement` в этом файле. Применено изменение и проверен результат. (Рис.6-7)

![Создание файла custom.conf](./images/lab1-6.png)  
*Рисунок 6 – Создание дополнительного файла конфигурации*

![Применение изменения и проверка параметра](./images/lab1-7.png)  
*Рисунок 7 – Применение изменений из дополнительного файла*

#### 3. Обработка ошибок в конфигурации
Намеренно внесена синтаксическая ошибка в конфигурационный файл (`invalid_value` вместо числового значения). Выполнена попытка перечитать конфигурацию. Изучено представление `pg_file_settings` для поиска записи об ошибке. Ошибка исправлена и конфигурация перечитана. (Рис.8-11)

![Ошибка в конфигурации](./images/lab1-8.png)  
*Рисунок 8 – Внесение синтаксической ошибки*

![Применение изменений и проверка](./images/lab1-9.png)  
*Рисунок 9 – Обнаружение ошибки в pg_file_settings*

![Исправление ошибки в файле](./images/lab1-10.png)  
*Рисунок 10 – Исправление ошибки в конфигурационном файле*

![Применение изменений и проверка](./images/lab1-11.png)  
*Рисунок 11 – Успешное применение исправленной конфигурации*

---

### Часть 3. Управление параметрами на уровне сеанса

#### 1. Команда SET
В рамках сеанса изменено значение параметра `work_mem` с помощью `SET`. Проверено новое значение. Завершена транзакция с помощью `ROLLBACK` и повторно проверено значение параметра. (Рис.12)

![Команды SET и ROLLBACK](./images/lab1-12.png)  
*Рисунок 12 – Использование команды SET и влияние ROLLBACK*

После выполнения `ROLLBACK` значение `work_mem` остается `16MB`, а не возвращается к исходному значению. Это происходит потому, что обычная команда `SET` устанавливает параметр на уровне сеанса, а не транзакции. Команда `ROLLBACK` откатывает только изменения данных в рамках транзакции, но не влияет на параметры сеанса, установленные через `SET`.

#### 2. Команда SET LOCAL
Открыта транзакция (`BEGIN`). Внутри транзакции использована `SET LOCAL` для изменения `work_mem`. Проверено изменение. После фиксации транзакции (`COMMIT`) проверено значение параметра снова. (Рис.13)

![Команда SET LOCAL и COMMIT](./images/lab1-13.png)  
*Рисунок 13 – Использование SET LOCAL и влияние COMMIT*

После выполнения `COMMIT` значение `work_mem` возвращается к предыдущему значению сеанса (`16MB`). Это ключевое отличие `SET LOCAL` от обычного `SET`: команда `SET LOCAL` устанавливает параметр только в рамках текущей транзакции. При завершении транзакции (как через `COMMIT`, так и через `ROLLBACK`) параметр автоматически возвращается к своему значению на уровне сеанса.

#### 3. Пользовательский параметр
Создан и установлено значение для пользовательского параметра (имя содержит точку: `app.my_setting`). Прочитано его значение с помощью `current_setting`. (Рис.14)

![Пользовательский параметр](./images/lab1-14.png)  
*Рисунок 14 – Работа с пользовательскими параметрами*

---

## Теоретическая часть

### Разница между контекстами параметров

**Postmaster** — параметры, которые могут быть изменены только при перезапуске сервера PostgreSQL. К ним относятся фундаментальные настройки архитектуры, такие как размер разделяемой памяти (`shared_buffers`), максимальное количество подключений (`max_connections`) и порт прослушивания (`port`). Эти параметры определяют базовую конфигурацию кластера и требуют полной перезагрузки процесса postmaster для применения изменений.

**Sighup** — параметры, которые применяются при перечитывании конфигурационных файлов без перезапуска сервера. Изменения вступают в силу после выполнения команды `SELECT pg_reload_conf()` или отправки сигнала SIGHUP процессу postmaster. К таким параметрам относятся настройки логирования (`log_min_duration_statement`), некоторые параметры безопасности и мониторинга. Это позволяет оперативно корректировать поведение сервера без прерывания обслуживания клиентов.

**User** — параметры, которые могут изменяться в рамках пользовательского сеанса командами `SET` и `SET LOCAL`. Примеры включают рабочую память для сортировок (`work_mem`), уровень изоляции транзакций и параметры оптимизатора запросов. Эти изменения действуют только в контексте текущего подключения и не влияют на другие сеансы.

### Разница между способами применения изменений

**ALTER SYSTEM** изменяет параметры на уровне всего кластера PostgreSQL, записывая новые значения в файл `postgresql.auto.conf`. Эти изменения становятся постоянными и применяются ко всем новым подключениям после перечитывания конфигурации или перезапуска сервера (в зависимости от контекста параметра). Команда требует привилегий суперпользователя и предназначена для административного управления конфигурацией.

**SET** устанавливает параметр только в рамках текущего сеанса до его завершения или следующего изменения. Изменения не сохраняются между подключениями и не влияют на другие пользовательские сеансы. Команда может использоваться обычными пользователями для параметров с контекстом user.

**SET LOCAL** действует еще более ограниченно — изменения применяются только в рамках текущей транзакции и автоматически отменяются при её завершении (как при `COMMIT`, так и при `ROLLBACK`). Это полезно для временной настройки параметров для выполнения конкретных операций.

### Процедура поиска и исправления ошибок в конфигурации

При внесении некорректных значений в конфигурационные файлы PostgreSQL не применяет изменения и сохраняет информацию об ошибках в системных представлениях. Для диагностики используется представление `pg_file_settings`, которое показывает все параметры из конфигурационных файлов, включая ошибочные записи.

Процедура поиска ошибки включает выполнение запроса:
```sql
SELECT name, setting, sourcefile, sourceline, error 
FROM pg_file_settings 
WHERE error IS NOT NULL;
```

Результат покажет имя параметра, некорректное значение, файл и строку с ошибкой, а также описание проблемы. После выявления и исправления ошибки в соответствующем файле необходимо повторно выполнить `SELECT pg_reload_conf()` для применения корректных настроек.

Такой подход обеспечивает стабильность работы сервера — даже при наличии ошибок в конфигурации PostgreSQL продолжает функционировать с предыдущими корректными настройками, позволяя администратору спокойно исправить проблемы.

---

## Выводы

В ходе выполнения лабораторной работы изучена архитектура PostgreSQL, основанная на модели "процесс на подключение", где главный процесс postmaster управляет кластером и порождает обслуживающие процессы для каждого клиента.

Получены практические навыки управления конфигурационными параметрами на разных уровнях. Освоено использование `ALTER SYSTEM` для изменений на уровне кластера с записью в `postgresql.auto.conf`, команд `SET` и `SET LOCAL` для настройки параметров сеанса и транзакции соответственно. Изучены различия между контекстами параметров: postmaster требует перезапуска сервера, sighup — перечитывания конфигурации, user позволяет изменения в рамках сеанса.

Освоена работа с представлениями `pg_settings` для анализа текущих параметров и `pg_file_settings` для диагностики конфигурационных файлов и поиска ошибок. Практическая работа с дополнительными конфигурационными файлами через `include_dir` показала гибкость системы управления настройками PostgreSQL.